# Nodographer

**Babel Aware AREDN Mesh Map**

An olsr/babel-compatible Python rewrite and derivative work of the original meshmap web application by KG6WXC.

## Overview

Nodographer is a mesh mapping web app and API consisting of two integrated components:

- **Backend** (`meshmapPoller`): Python async daemon that polls AREDN nodes, collects network topology and node data, manages a relational database, and generates JSON data files. Runs as a systemd service with configurable polling intervals and supports both MySQL/MariaDB and SQLite.
  
- **Frontend**: Leaflet-based interactive web interface for visualizing the mesh map with grouped layer controls, search functionality, and a detailed node report page. Deployed via symlink into the web server's document root and consumes data files generated by the backend.

Together, these components provide real-time AREDN mesh network visualization and node status monitoring.

The entire project (source code, configuration, data files) lives in `/srv/meshmap`, making it very easy to modify and develop with VSCode or any text editor. The only external components are the database files (stored in `/var/lib/mysql/` or as a SQLite file you configure) and two symlinks: one linking the frontend into the web root (`/var/www/html/meshmap`) and one linking the systemd unit file (`/etc/systemd/system/meshmapPoller.service`).

## System Requirements

- Linux with systemd (developed and tested on Debian 13, works on any systemd-based distribution)
- Python 3.10 or higher with `python3-venv`
- Web server serving `/var/www/html` (Nginx used for development and testing)
- Database: MariaDB/MySQL (default) or SQLite
- `git`

## Features

- **Comprehensive Logging**: Integrated with systemd journal (INFO, DEBUG, ERROR levels)
- **Flush Mode**: `--flush` flag clears stale data and resets node state

### Prerequisites

- Linux with `systemd` (developed and tested on Debian 13, works on any systemd-based distribution)
- Linux user with sudo privileges
- Web server serving `/var/www/html` (Nginx used for development and testing)
- Python 3.10+ with `python3-venv` and `pip`
- `git`
- Database: MariaDB/MySQL (default) or SQLite

**Install required packages:**
```bash
sudo apt update
sudo apt install -y python3 python3-venv python3-pip git mariadb-server nginx
```

### Clone the repository to your local drive

```bash
sudo mkdir -p /srv
sudo chown "$USER":"$USER" /srv
cd /srv
git clone https://github.com/AI7BQ/nodographer.git meshmap
```

You now own the cloned application files as your user (`$USER`). 

### Quick Start

In a hurry? Run the following installation script:
```bash
sudo /srv/meshmap/INSTALL.sh
```

### Manual Method

The following steps configure the application for development and testing the same way as the INSTALL.sh shown above. Before deploying as a systemd service, you'll transfer ownership to the `meshmap` service user.

### Create dedicated system user

For security, the poller runs as a dedicated `meshmap` system user with minimal privileges. This follows the **principle of least privilege**: each process should have only the minimum permissions necessary to perform its function.

By running the poller as `meshmap` instead of `root` or `www-data`, we limit the damage if the service is compromised:
- No login shell access (`/bin/false`)
- No access to other user home directories
- Only read/write access to application directories
- Cannot modify system files
- Isolated from web server processes

Create system user named `meshmap`. This user will not have shell access:
```bash
sudo useradd -r -s /bin/false -d /srv/meshmap -c "MeshMap Poller Service" meshmap
```

Flags explained:
- `-r`: Create a system account (UID < 1000, no aging/expiration)
- `-s /bin/false`: No shell login allowed (security)
- `-d /srv/meshmap`: Set home directory
- `-c`: Descriptive comment for the account

### Setup the Python virtual environment and dependencies

Transfer backend ownership to the `meshmap` user, then create the virtual environment as that user:

```bash
sudo chown -R meshmap:meshmap /srv/meshmap/backend /srv/meshmap/.cache
cd /srv/meshmap/backend
sudo -H -u meshmap python3 -m venv venv
sudo -H -u meshmap venv/bin/pip install --upgrade pip
sudo -H -u meshmap venv/bin/pip install -r requirements.txt
```

**Python packages** (from `requirements.txt`):
- `aiohttp>=3.9.0` – async HTTP client for node polling
- `aiomysql>=0.2.0` – MySQL/MariaDB async adapter
- `aiosqlite>=0.19.0` – SQLite async adapter
- `uvloop>=0.19.0` – (optional) high-performance event loop

By transferring ownership before creating the venv, the `meshmap` user can create and manage the virtual environment, ensuring the systemd service has proper access to all installed packages.

**Note**: After this step, you'll need `sudo` to edit backend files (e.g., `sudo nano /srv/meshmap/settings.ini`).

### Database setup

Create the database and user to match `settings.ini` defaults (`node_map`, user `mesh-map`). Adjust credentials as needed.

**For MariaDB/MySQL:**
```bash
sudo mysql -u root <<'SQL'
CREATE DATABASE IF NOT EXISTS node_map CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
CREATE USER IF NOT EXISTS 'mesh-map'@'localhost' IDENTIFIED BY 'password';
GRANT ALL PRIVILEGES ON node_map.* TO 'mesh-map'@'localhost';
FLUSH PRIVILEGES;
SQL
```

The database tables (`node_info`, `map_info`, `aredn_info`) are created automatically when the poller first connects.

**For SQLite:**
Set `SQL_TYPE = "sqlite"` in `settings.ini` and point `webpageDataDir` to a writable path. The database file and tables are created automatically on first run.

### Configure the application

Edit `/srv/meshmap/settings.ini` to match your environment:
- Database credentials and type
- `localnode` hostname/IP (default: `localnode.local.mesh`)
- `webpageDataDir` path (default: `/srv/meshmap/frontend/data`)
- Map center coordinates and zoom level
- Tile servers and priority
- Node expiration intervals

See inline comments in `settings.ini` for all options.

### Expose the frontend to the web server

Symlink the frontend into the web root:
```bash
sudo ln -s /srv/meshmap/frontend /var/www/html/meshmap
```

The site will be served at `http://<hostname>.local.mesh/meshmap/`.

### Transfer ownership to service user (before systemd deployment)

Before installing the systemd service, transfer ownership from your user to the `meshmap` service user:

```bash
# Backend owned by meshmap user
sudo chown -R meshmap:meshmap /srv/meshmap/backend

# Data directory: meshmap writes, www-data reads
sudo chown -R meshmap:www-data /srv/meshmap/frontend/data
sudo chmod 775 /srv/meshmap/frontend/data
```

After this step, you'll need `sudo` to edit files in `/srv/meshmap/backend` (e.g., `sudo nano /srv/meshmap/settings.ini`). This is intentional—it prevents accidental changes to production configuration.

### Install systemd service

The unit file for the MeshMap Poller service is provided at /srv/meshmap/backend/meshmapPoller.service.

A symbolic link (symlink) must be created in /etc/systemd/system/ that points to the unit file in the application directory. This ensures systemd can find the service unit while keeping the application files neatly organized under /srv/meshmap.

Use the following commands to create the symlink, reload systemd, and immediately enable and start the service:

```bash
sudo ln -s /srv/meshmap/backend/meshmapPoller.service /etc/systemd/system/meshmapPoller.service
sudo systemctl daemon-reload
sudo systemctl enable --now meshmapPoller.service
```

### Smoke test

Run a one-time poll to verify everything works. Since we're testing as your user account, temporarily allow access:
```bash
cd /srv/meshmap/backend
source venv/bin/activate
sudo -u meshmap ./venv/bin/python3 meshmapPoller.py --once
```

Verify that two JSON files appear under `/srv/meshmap/frontend/data` and that the web page renders at `http://<hostname>.local.mesh/meshmap/`.

**Note**: The smoke test runs as the `meshmap` user using `sudo -u`. This confirms permissions are set correctly before enabling the systemd service.

### Service management

```bash
sudo systemctl status meshmapPoller.service           # Start the poller
sudo systemctl stop meshmapPoller.service             # Stop the poller
sudo systemctl restart meshmapPoller.service          # Restart the poller
sudo journalctl -u meshmapPoller.service -f           # Follow logs
sudo journalctl -u meshmapPoller.service -p err       # Errors only
```

### Upgrades

```bash
cd /srv/meshmap
sudo systemctl stop meshmapPoller.service
git pull
cd backend && source venv/bin/activate && pip install -r requirements.txt
sudo systemctl start meshmapPoller.service
```

### Running as a different user

The default systemd unit runs as `meshmap`. To run as `www-data` instead, edit `User` and `Group` in `/srv/meshmap/backend/meshmapPoller.service` and ensure file ownership matches.

### SELinux/AppArmor

If SELinux or AppArmor is enforcing, allow the service user to read `/srv/meshmap/frontend` and write `/srv/meshmap/frontend/data`. Policy adjustments are environment-specific.

### Uninstall

```bash
sudo systemctl disable --now meshmapPoller.service
sudo rm -f /etc/systemd/system/meshmapPoller.service
sudo systemctl daemon-reload
sudo rm -f /var/www/html/meshmap
sudo rm -rf /srv/meshmap
```

## Quick Start

After installation:

```bash
# Create Python virtual environment
cd /srv/meshmap/backend
python3 -m venv venv
source venv/bin/activate
pip install --upgrade pip
pip install -r requirements.txt

# Configure settings
nano ../settings.ini

# Run one poll cycle (smoke test)
./meshmapPoller.py --once

# Start the systemd service
sudo systemctl start meshmapPoller.service
sudo systemctl enable meshmapPoller.service

# View logs
sudo journalctl -u meshmapPoller.service -f
```

## Configuration

Edit `settings.ini` (at project root) to configure:

- Database connection (type, host, credentials)
- Localnode address for topology fetching
- Map tile servers and priority
- Web data output directory
- Map center and zoom level
- Node expiration intervals

See inline comments in `settings.ini` for details.

## Command Line Options

```bash
./meshmapPoller.py               # Run in daemon mode
./meshmapPoller.py --once        # Single poll and exit
./meshmapPoller.py --flush       # Clear stale data and reset node state
./meshmapPoller.py --config FILE # Use custom config file
./meshmapPoller.py --help        # Show help
```

## Web Interface

The frontend is accessed at `http://<server>/meshmap/` (after installation).

- **Map View**: Interactive Leaflet map showing nodes and links
- **Layer Control**: Toggle between AREDN and Internet tile servers
- **Search**: Find nodes by name or IP
- **Node Report**: Detailed statistics and filtering via `node_report/`

## Architecture

### Backend Components

- **`ConfigManager`**: Configuration loading and validation
- **`NodeInfo`**: Data class for node state
- **`DatabaseAdapter`**: Abstract base for async DB operations
  - `MySQLAdapter`: MySQL/MariaDB implementation
  - `SQLiteAdapter`: SQLite implementation
- **`NodePoller`**: Individual node HTTP polling
- **`MeshPollingDaemon`**: Main coordinator for all polling operations

### Data Flow

**First Run (Full Speed)**
1. Fetch network topology from nodelistNode
2. Build list of all nodes with hop counts
3. Update database with topology
4. Poll all nodes in parallel (no rate limiting)
5. Calculate link distances and bearings
6. Generate JSON data files for web interface and API
7. If `--once` flag is set then exit
8. Wait 10 minutes
9. Goto step 10

**Subsequent Runs (Rate Limited)**
10. Fetch network topology from nodelistNode
11. Build list of all nodes with hop counts
12. Update database with topology
13. Poll all nodes in parallel (rate limited)
14. Calculate link distances and bearings
15. Generate JSON data files for web interface and API
16. Wait 10 minutes
17. Goto step 10

## APIs and Data Files

### Generated JSON Data Files

The backend generates two JSON files in `/srv/meshmap/frontend/data/` (configurable via `webpageDataDir`):

#### `map_data.json`
Contains all data needed for the interactive map visualization:
- **`mapInfo`**: Map configuration and metadata
  - Tile servers, map center, zoom level, attribution
  - Browser title, contact info, distance units (miles/kilometers)
- **`pollingInfo`**: Polling statistics and node counts
  - Total nodes, successfully polled, response times
  - Protocol breakdown (OLSR, Babel, Combo)
  - Link counts, nodes with errors, nodes without location
- **`allDevices`**: All nodes organized by frequency band
  - `noRF`: Nodes without RF support
  - `supernode`: Supernode stations
  - `900`, `2.4`, `5`: Nodes by frequency band (MHz)
  - Each node includes: name, IP, lat/lon, firmware, model, status, links

#### `node_report_data.json`
Detailed node information for the interactive report page (DataTables format):
- Node callsign, IP address, coordinates
- Firmware version, model, hardware
- Uptime, load average, services
- Hops away, response time
- Tunnel status, antenna information
- Last seen timestamp

### AREDN Node APIs (Mesh Network)

Nodographer polls standard AREDN node API endpoints. These are accessed by the `NodePoller` class:

```
http://<node>/cgi-bin/sysinfo.json?nodes=1      # Node information from topology
http://<node>/cgi-bin/sysinfo.json?lqm=1        # Link quality metrics (preferred)
http://<node>/cgi-bin/sysinfo.json?link_info=1  # Link information (fallback)
```

These endpoints are polled from each node to gather:
- Node status, firmware version, model, hardware ID
- GPS location (latitude/longitude)
- Network interfaces and IP addresses
- Uptime, load average, services
- RF and antenna information

The topology endpoints are queried from the `nodelistNode` (configured in `settings.ini`):
```
http://<nodelistNode>/cgi-bin/sysinfo.json?nodes=1      # All nodes in mesh
http://<nodelistNode>/cgi-bin/sysinfo.json?lqm=1        # Link quality metrics
http://<nodelistNode>/cgi-bin/sysinfo.json?link_info=1  # Detailed link info
```

### Nodographer Application Endpoints

The Nodographer frontend exposes these HTTP endpoints (served by Nginx) for programmatic access to mesh data:

#### Map Data Endpoint
```
GET /meshmap/data/map_data.json
```
Returns complete map visualization data including all nodes, links, and map configuration. Used by the interactive map and can be consumed by external applications.

**Response Structure**:
- `mapInfo`: Map configuration (tile servers, center, zoom, title, distance units)
- `pollingInfo`: Statistics (total nodes, response times, link counts, errors)
- `allDevices`: Nodes organized by frequency band (900MHz, 2.4GHz, 5GHz, etc.)

**Example**:
```bash
curl -s http://localhost/meshmap/data/map_data.json | jq '.pollingInfo'
```

If you use Chrome, the "JSON Viewer" extension is highly recommended for viewing and searching JSON data in a clear, hierarchical tree structure.

#### Node Report Endpoint
```
GET /meshmap/data/node_report_data.json
```
Returns detailed tabular node data for the interactive report page. Contains per-node information suitable for DataTables filtering, sorting, and export.

**Response Format**: Array of objects, one per node:
```json
[
  {
    "callsign": "W5ABC",
    "ip": "10.89.88.45",
    "latitude": 35.1234,
    "longitude": -97.5678,
    "firmware": "3.2.1.0",
    "model": "Mikrotik RB912UAG-5HPnD",
    "uptime": "45 days",
    "tunnel": "none",
    "services": "http, ssh",
    "last_seen": "2025-01-15T12:34:56"
  },
  ...
]
```

#### Documentation Page
```
GET /meshmap/readme.html
```
Serves the project README rendered as an interactive HTML page with navigation links and GitHub-style formatting.

#### Web Interface
```
GET /meshmap/
```
Interactive Leaflet map with layer controls, search, and node visualization.

```
GET /meshmap/node_report/
```
Interactive DataTables report page with node statistics, filtering, and export capabilities.

## License

GPLv3 or later

**Original PHP implementation**: KG6WXC (2016-2024)  
**Python backend rewrite**: AI7BQ 2025

## Support & Contribution

- GitHub Issues: https://github.com/AI7BQ/nodographer
- AREDN Mesh: https://www.arednmesh.org/
- Original Project: https://github.com/r1de/KG6WXC-meshmap